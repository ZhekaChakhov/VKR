# -*- coding: utf-8 -*-
"""potential.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-fWR29r8WcwkAKqKc-o6wJY8iWYoXz2s
"""

import numpy as np
import matplotlib.pyplot as plt
from sympy import *
from scipy.integrate import odeint
from IPython.display import display
import math
import time 

start_time = time.time() ## точка отсчета времени

def near_obst(arr, i): # ближайшее препятствие
  dist = np.zeros(len(arr))
  minDist = math.sqrt((arr[0][0] - robotx[i])**2 + (arr[0][1] - roboty[i])**2)
  j = 0
  while(j < len(arr)):
    dist[j] = math.sqrt((arr[j][0] - robotx[i])**2 + (arr[j][1] - roboty[i])**2)
    if (dist[j] <= minDist):
      x = arr[j][0]
      y = arr[j][1]
      minDist = dist[j]
    j += 1

  return minDist, x, y


# начальные данные
start = [0, 0]
goal = [10, 10]
obst_s = [[3, 4] , [6, 6], [8, 6]] # препятствие
psi0 = pi/4 # начальный курс робота

# константы
epsilon = 0.001 # погрешность решения задачи
dmin = 2 # минимальное расстояние до препятствия
p0 = 1 # некоторое малое расстояние до цели
ka = 0.1 # коэфф притяжения
kr = 0.1 # коэфф отталкивания

T = 300

psi = np.zeros(T)
p = np.zeros(T) #расстояние до цели
d = np.zeros(T) #расстояние до препятствия
Fatt_x = np.zeros(T)
Fatt_y = np.zeros(T)
Frep_x = np.zeros(T)
Frep_y = np.zeros(T)
x0 = np.zeros(T)
y0 = np.zeros(T)

robotx = np.zeros(T)
roboty = np.zeros(T)

psi[0] = psi0
robotx[0] = start[0]
roboty[0] = start[1]

i = 0
vmax = 0

while(i < (T - 1)):
  d[i], x0[i], y0[i] = near_obst(obst_s, i)
  p[i] = math.sqrt((goal[0] - robotx[i])**2 + (goal[1] - roboty[i])**2)

  if (d[i] <= dmin):
    Frep_x[i] = (kr * (robotx[i] - x0[i]) * (1/d[i] - 1/dmin))/(d[i]**3)
    Frep_y[i] = (kr * (roboty[i] - y0[i]) * (1/d[i] - 1/dmin))/(d[i]**3)
  else:
    Frep_x[i] = 0
    Frep_x[i] = 0
    
  if (p[i] <= p0):
    Fatt_x[i] = - ka * (robotx[i] - goal[0])
    Fatt_y[i] = - ka * (roboty[i] - goal[1])
  else:
    Fatt_x[i] = - ka * (robotx[i] - goal[0]) / p[i]
    Fatt_y[i] = - ka * (roboty[i] - goal[1]) / p[i]

  if (p[i] > epsilon):
      robotx[i+1] = robotx[i] + Fatt_x[i] + Frep_x[i]
      roboty[i+1] = roboty[i] + Fatt_y[i] + Frep_y[i]
  else:
      robotx[i+1] = robotx[i]
      roboty[i+1] = roboty[i]

  v = math.sqrt((robotx[i+1] - robotx[i])**2 + (roboty[i+1] - roboty[i])**2)
  if (v > vmax):
    vmax = v

  i += 1

  psi[i] = math.acos((robotx[i] - robotx[i-1]) / math.sqrt((robotx[i] - robotx[i-1])**2 + (roboty[i] - roboty[i-1])**2))

# print("robotx = ", robotx)
# print("")
# print("roboty = ", roboty)
# print("")
# print("Fatt_x = ", Fatt_x)
# print("")
# print("Fatt_y = ", Fatt_y)
# print("")
# print("Frep_x = ", Frep_x)
# print("")
# print("Frep_y = ", Frep_y)
# print("")
# print("p = ", p)
# print("")
# print("d = ", d)
# print("")
# print("vmax = ", vmax)
# print("")

i = 0

while(i < len(obst_s)):
  plt.plot(obst_s[i][0], obst_s[i][1], 'ro')
  i += 1

plt.plot(robotx, roboty, 'yo-')
plt.plot(goal[0], goal[1], 'bo')
plt.grid()
plt.show()

end_time = time.time() - start_time ## время работы программы

print("")
print("time: ", end_time) ## вывод времени