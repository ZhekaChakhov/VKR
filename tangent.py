# -*- coding: utf-8 -*-
"""tangent.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15YCENCTymkOWlfdos2I9nLVzJyxqzqIK
"""

import numpy as np
import matplotlib.pyplot as plt
from sympy import *
from scipy.integrate import odeint
from IPython.display import display
import math
import time 

start_time = time.time() ## точка отсчета времени


def near_obst(arr, i): # ближайшее препятствие
  dist = np.zeros(len(arr))
  j = 0
  while(j < len(arr)):
    dist[j] = math.sqrt((arr[j][0] - robotx[i])**2 + (arr[j][1] - roboty[i])**2)
    j += 1
  return min(dist)


# начальные данные
start = [0, 0]
goal = [10, 10]
obst_s = [[3, 3] , [6, 6], [8, 6]] # препятствия
psi0 = pi/4 # начальный курс робота

# константы
epsilon = 0.1 # погрешность решения задачи
dmin = 2 # минимальное расстояние до препятствия
kw = 1 # коэфф пропорциональности угл. скорости
kp = 1 # коэфф пропорциональности курсового угла
vmax = 0.1 # макс. скорость
R = 0.1 # радиус колеса
B = 0.1 # расстояние между колесами

T = 300

psi = np.zeros(T)
alpha = np.zeros(T)
theta = np.zeros(T)
w1 = np.zeros(T)
w2 = np.zeros(T)
p = np.zeros(T) #расстояние до цели
d = np.zeros(T) #расстояние до препятствия

robotx = np.zeros(T)
roboty = np.zeros(T)

psi[0] = psi0
robotx[0] = start[0]
roboty[0] = start[1]

i = 0

while(i < (T - 1)):
  d[i] = near_obst(obst_s, i)
  p[i] = math.sqrt((goal[0] - robotx[i])**2 + (goal[1] - roboty[i])**2)
  theta[i] = math.acos((goal[0] - robotx[i]) / math.sqrt((goal[0] - robotx[i])**2 + (goal[1] - roboty[i])**2))
  
  if (d[i] < dmin):
    alpha[i] = theta[i] - psi[i] - kp * (dmin - d[i])
  else:
    alpha[i] = theta[i] - psi[i]  

  w1[i] = 0.5 * (2 / R * (vmax * math.tanh(p[i]) * math.cos(alpha[i])) +
                 B / R * (kw * alpha[i] + vmax * math.tanh(p[i]) / p[i] *
                            math.sin(alpha[i]) * math.cos(alpha[i])))
  
  w2[i] = 0.5 * (2 / R * (vmax * math.tanh(p[i]) * math.cos(alpha[i])) -
                 B / R * (kw * alpha[i] + vmax * math.tanh(p[i]) / p[i] *
                            math.sin(alpha[i]) * math.cos(alpha[i])))
  
  psi[i + 1] = psi[i] + (w1[i] - w2[i]) * R / B
  
  if (p[i] > epsilon):
    robotx[i+1] = robotx[i] + cos(psi[i]) * (w1[i] + w2[i]) * R / 2
    roboty[i+1] = roboty[i] + sin(psi[i]) * (w1[i] + w2[i]) * R / 2

  else:
    robotx[i+1] = robotx[i]
    roboty[i+1] = roboty[i]

  i +=1
  


# print("robotx = ", robotx)
# print("")
# print("roboty = ", roboty)
# print("")
# print("v = ", v)
# print("")
# print("w1 = ", w1)
# print("")
# print("w2 = ", w2)
# print("")
# print("p = ", p)
# print("")
# print("alpha = ", alpha)
# print("")
# print("d = ", d)
# print("")

# plt.figure(figsize=(10,10))

i = 0

while(i < len(obst_s)):
  plt.plot(obst_s[i][0], obst_s[i][1], 'ro')
  i += 1

plt.plot(robotx, roboty, 'yo-')
plt.plot(goal[0], goal[1], 'bo')
plt.grid()
plt.show()

end_time = time.time() - start_time ## время работы программы

print("")
print("time: ", end_time) ## вывод времени