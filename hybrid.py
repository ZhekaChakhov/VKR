# -*- coding: utf-8 -*-
"""hybrid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dMZnwi733fWwTDyikfqpHF9GWiXO9wCw
"""

import numpy as np
import matplotlib.pyplot as plt
from sympy import *
from scipy.integrate import odeint
from IPython.display import display
import math

import time 

start_time = time.time() ## точка отсчета времени

def near_obst(arr, i): # ближайшее препятствие
  dist = np.zeros(len(arr))
  minDist = math.sqrt((arr[0][0] - robotx[i])**2 + (arr[0][1] - roboty[i])**2)
  j = 0
  while(j < len(arr)):
    dist[j] = math.sqrt((arr[j][0] - robotx[i])**2 + (arr[j][1] - roboty[i])**2)
    if (dist[j] <= minDist):
      x = arr[j][0]
      y = arr[j][1]
      minDist = dist[j]
    j += 1

  return minDist, x, y

# начальные данные
start = [0, 0]
goal = [10, 10]
obst_s = [[3, 3] , [6, 6], [8, 6]] # препятствия
psi0 = pi/4 # начальный курс робота

# константы
epsilon = 0.001 # погрешность решения задачи
dmin = 2 # минимальное расстояние до препятствия
kw = 0.5 # коэфф пропорциональности угл. скорости
kp = 1 # коэфф пропорциональности курсового угла
vmax = 0.1 # макс. скорость
R = 0.1 # радиус колеса
B = 0.1 # расстояние между колесами
p0 = 1 # некоторое малое расстояние до цели
ka = 0.1 # коэфф притяжения
kr = 0.1 # коэфф отталкивания

T = 300

psi = np.zeros(T)
alpha = np.zeros(T)
theta = np.zeros(T)
w1 = np.zeros(T)
w2 = np.zeros(T)
p = np.zeros(T) #расстояние до цели
d = np.zeros(T) #расстояние до препятствия
Fatt_x = np.zeros(T)
Fatt_y = np.zeros(T)
Frep_x = np.zeros(T)
Frep_y = np.zeros(T)
x0 = np.zeros(T)
y0 = np.zeros(T)

robotx = np.zeros(T)
roboty = np.zeros(T)

psi[0] = psi0
robotx[0] = start[0]
roboty[0] = start[1]

i = 0

while(i < (T - 1)):
  # общие вычисления
  d[i], x0[i], y0[i] = near_obst(obst_s, i)
  p[i] = math.sqrt((goal[0] - robotx[i])**2 + (goal[1] - roboty[i])**2)

  # вычисления для метода тангенциального избегания
  theta[i] = math.acos((goal[0] - robotx[i]) / math.sqrt((goal[0] - robotx[i])**2 + (goal[1] - roboty[i])**2))
  
  if (d[i] < dmin):
    alpha[i] = theta[i] - psi[i] - kp * (dmin - d[i])
  else:
    alpha[i] = theta[i] - psi[i]  

  w1[i] = 0.5 * (2 / R * (vmax * math.tanh(p[i]) * math.cos(alpha[i])) +
                 B / R * (kw * alpha[i] + vmax * math.tanh(p[i]) / p[i] *
                            math.sin(alpha[i]) * math.cos(alpha[i])))
  
  w2[i] = 0.5 * (2 / R * (vmax * math.tanh(p[i]) * math.cos(alpha[i])) -
                 B / R * (kw * alpha[i] + vmax * math.tanh(p[i]) / p[i] *
                            math.sin(alpha[i]) * math.cos(alpha[i])))
  
  psi[i + 1] = psi[i] + (w1[i] - w2[i]) * R / B
  
  # вычисления для метода потенциальных полей
  if (d[i] <= dmin):
    Frep_x[i] = (kr * (robotx[i] - x0[i]) * (1/d[i] - 1/dmin))/(d[i]**3)
    Frep_y[i] = (kr * (roboty[i] - y0[i]) * (1/d[i] - 1/dmin))/(d[i]**3)
  else:
    Frep_x[i] = 0
    Frep_x[i] = 0
    
  if (p[i] <= p0):
    Fatt_x[i] = - ka * (robotx[i] - goal[0])
    Fatt_y[i] = - ka * (roboty[i] - goal[1])
  else:
    Fatt_x[i] = - ka * (robotx[i] - goal[0]) / p[i]
    Fatt_y[i] = - ka * (roboty[i] - goal[1]) / p[i]

  # вычисление следующей позиции робота
  if (((Fatt_x[i] + Frep_x[i]) < epsilon) and ((Fatt_y[i] + Frep_y[i]) < epsilon)):
    robotx[i+1] = robotx[i] + cos(psi[i]) * (w1[i] + w2[i]) * R / 2
    roboty[i+1] = roboty[i] + sin(psi[i]) * (w1[i] + w2[i]) * R / 2

  else:
    if (p[i] > epsilon):
      robotx[i+1] = robotx[i] + Fatt_x[i] + Frep_x[i]
      roboty[i+1] = roboty[i] + Fatt_y[i] + Frep_y[i]
    else:
      robotx[i+1] = robotx[i]
      roboty[i+1] = roboty[i]

  i += 1


i = 0

while(i < len(obst_s)):
  plt.plot(obst_s[i][0], obst_s[i][1], 'ro')
  i += 1

plt.plot(robotx, roboty, 'yo-')
plt.plot(goal[0], goal[1], 'bo')
plt.grid()
plt.show()

end_time = time.time() - start_time ## время работы программы

print("")
print("time: ", end_time) ## вывод времени